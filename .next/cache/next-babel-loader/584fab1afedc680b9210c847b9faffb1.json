{"ast":null,"code":"import _defineProperty from \"C:/Users/Lenovo/Desktop/ibtikar/projects/product_task/product/node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n//reducer(action,state) //return update state\nimport * as actionType from \"../constants/actionTypes\";\nconst initState = {\n  cart: [],\n  itemsNum: 0\n};\nexport default function cartReducer(state = initState, action) {\n  switch (action.type) {\n    case actionType.ADD_ITEM_TO_CART:\n      {\n        let newItem = action.payload.newItem;\n        let existItem = state.cart.find(item => item.id === newItem.id); //check if item exist in cart or not\n\n        if (!existItem) {\n          newItem.quantity = 1; //if not exist add it with q = 1\n\n          return _objectSpread(_objectSpread({}, state), {}, {\n            cartLoader: false,\n            newItem,\n            itemsNum: state.itemsNum + 1,\n            //inc no of items to badge no\n            cart: [...state.cart, newItem] //reload cart\n\n          });\n        } else {\n          newItem.quantity += 1; //if item is already exit in cart //inc it's quantity\n\n          return _objectSpread(_objectSpread({}, state), {}, {\n            cartLoader: false,\n            newItem,\n            itemsNum: state.itemsNum,\n            cart: [...state.cart] //reload cart\n\n          });\n        }\n      }\n\n    case actionType.DELETE_ITEM_IN_CART:\n      {\n        let deletedItem = action.payload.deletedItem;\n        deletedItem.quantity = 0; //set quantity of deleted item to 0\n\n        return _objectSpread(_objectSpread({}, state), {}, {\n          deletedItem,\n          itemsNum: state.itemsNum - 1,\n          cart: state.cart.filter(item => item.id !== deletedItem.id) //filter cart after delete item\n\n        });\n      }\n\n    case actionType.INCREMENT_QUANTITY:\n      {\n        let item = action.payload.item;\n        let newCart = JSON.parse(JSON.stringify(state.cart)); //deep copy\n\n        let index = newCart.findIndex(itemx => itemx.id === item.id); // find this item in cart\n\n        item.quantity = ++item.quantity; //inc it's q\n\n        newCart.splice(index, 1, item); //replace it with new item\n\n        return _objectSpread(_objectSpread({}, state), {}, {\n          cart: [...newCart]\n        });\n      }\n\n    case actionType.DECREMENT_QUANTITY:\n      {\n        let item = action.payload.item;\n        let newCart = JSON.parse(JSON.stringify(state.cart)); //deep copy\n\n        let index = state.cart.indexOf(item); // find this item in cart\n\n        item.quantity = --item.quantity; //dec its quantity\n\n        if (action.payload.item.quantity === 0) {\n          //if q=0\n          newCart = newCart.filter(product => product.id !== action.payload.item.id //delete this item\n          );\n          state.itemsNum = state.itemsNum - 1; //dec no of items in badge\n        } else {\n          newCart.splice(index, 1, item); //else dec it's quantity\n        }\n\n        return _objectSpread(_objectSpread({}, state), {}, {\n          cart: [...newCart]\n        });\n      }\n\n    default:\n      return state;\n  }\n}","map":{"version":3,"sources":["C:/Users/Lenovo/Desktop/ibtikar/projects/product_task/product/src/redux/reducers/cart.js"],"names":["actionType","initState","cart","itemsNum","cartReducer","state","action","type","ADD_ITEM_TO_CART","newItem","payload","existItem","find","item","id","quantity","cartLoader","DELETE_ITEM_IN_CART","deletedItem","filter","INCREMENT_QUANTITY","newCart","JSON","parse","stringify","index","findIndex","itemx","splice","DECREMENT_QUANTITY","indexOf","product"],"mappings":"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","sourcesContent":["//reducer(action,state) //return update state\r\n\r\nimport * as actionType from \"../constants/actionTypes\";\r\nconst initState = {\r\n  cart: [],\r\n  itemsNum: 0,\r\n};\r\nexport default function cartReducer(state = initState, action) {\r\n  switch (action.type) {\r\n    case actionType.ADD_ITEM_TO_CART: {\r\n      let newItem = action.payload.newItem;\r\n      let existItem = state.cart.find((item) => item.id === newItem.id); //check if item exist in cart or not\r\n      if (!existItem) {\r\n        newItem.quantity = 1; //if not exist add it with q = 1\r\n        return {\r\n          ...state,\r\n          cartLoader: false,\r\n          newItem,\r\n          itemsNum: state.itemsNum + 1, //inc no of items to badge no\r\n          cart: [...state.cart, newItem], //reload cart\r\n        };\r\n      } else {\r\n        newItem.quantity += 1; //if item is already exit in cart //inc it's quantity\r\n        return {\r\n          ...state,\r\n          cartLoader: false,\r\n          newItem,\r\n          itemsNum: state.itemsNum,\r\n          cart: [...state.cart], //reload cart\r\n        };\r\n      }\r\n    }\r\n    case actionType.DELETE_ITEM_IN_CART: {\r\n      let deletedItem = action.payload.deletedItem;\r\n      deletedItem.quantity = 0; //set quantity of deleted item to 0\r\n      return {\r\n        ...state,\r\n        deletedItem,\r\n        itemsNum: state.itemsNum - 1,\r\n        cart: state.cart.filter((item) => item.id !== deletedItem.id), //filter cart after delete item\r\n      };\r\n    }\r\n    case actionType.INCREMENT_QUANTITY: {\r\n      let item = action.payload.item;\r\n      let newCart = JSON.parse(JSON.stringify(state.cart)); //deep copy\r\n      let index = newCart.findIndex((itemx) => itemx.id === item.id); // find this item in cart\r\n      item.quantity = ++item.quantity; //inc it's q\r\n      newCart.splice(index, 1, item); //replace it with new item\r\n      return {\r\n        ...state,\r\n        cart: [...newCart],\r\n      };\r\n    }\r\n    case actionType.DECREMENT_QUANTITY: {\r\n      let item = action.payload.item;\r\n      let newCart = JSON.parse(JSON.stringify(state.cart)); //deep copy\r\n      let index = state.cart.indexOf(item); // find this item in cart\r\n      item.quantity = --item.quantity; //dec its quantity\r\n\r\n      if (action.payload.item.quantity === 0) {\r\n        //if q=0\r\n        newCart = newCart.filter(\r\n          (product) => product.id !== action.payload.item.id //delete this item\r\n        );\r\n        state.itemsNum = state.itemsNum - 1; //dec no of items in badge\r\n      } else {\r\n        newCart.splice(index, 1, item); //else dec it's quantity\r\n      }\r\n      return {\r\n        ...state,\r\n        cart: [...newCart],\r\n      };\r\n    }\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}